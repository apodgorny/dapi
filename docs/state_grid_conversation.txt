WHEN – is a construct telling the agents when an AGENT FLOW arrives at a certain place in a possible EVENT GRID. It is a map of foreseen situations. COORDINATOR stirs the flow in the way that it is always in one of them and no other situation. It is a coordinate system with agent axis. Therefore demands of an agent to measure itself in a certain duality. Or dualities. Multidimensional agents must be fun to talk to.

So the coordinate grid defines topology of event preference defined through a position of a system in normalized scale between extremes of a duality.

What then remains to explore is programming not of agents, but of situations to which the agents will shift a given external system affected by a set of tools.

Agents given their expertise in a given set of dualities can (if feel really excited about it) have input into prompts of other agents. Not without a coordinator's input. He has control not over the situations, but over a choice of the trajectory through them.

Prompts are crafted in such a way that certain areas of prompt are devoted to opinion of a subset of agents. When he chooses to ask he sends a question to a chat room with a set of agents, and they all respond in a couple of words. These opinions are then incorporated into prompt for asker to carry out. Coordinator's job, then, narrows down to publishing preferred shifts (direction and magnitude) in each of affected duality ranges. Agents give their expertise biased on that preferred shift.

Asker can provide bias into their opinion by using option "Ask as" which is a few words about personality to whom they will respond. Certainly they also can use "Respond As". They don't have to be presented as "expert in dualities such and such".

Then it is a new kind of tool. A tool that does not lead to outside world, but provides structure of communication between agents. A chat room is one of them. Perhaps you can come up with a name in line with Agent, Tool, Function, Process ... ?

In the future, prompts will be divided into areas of external influence. They will be defined with their own description about what they in context of entire prompt. Another term in definition will be a part of speech they represent to be inserted seamlessly into prompt when generated outside.

Prompt Variable. They exist today but in rudimentary state.

Here is an example of WHEN. Imagine an EVENT GRID is a recursive tree. An agent may have states against this tree. One state is STATE_IN another STATE_OUT. Certainly he should have ability to do actions WHEN STATEs happen. Against this EVENT GRID you would also design a way their internal state is held together.

For example writing a recursive book could demand that certain change would be done when each level is reached from the root. Like at higher levels, you'd plan to divide a story into beginning, body and the end. You'd want to assign emotional significance to these parts. On the next level game changes, now there is a context of which part it is so we'd want to stir an agent towards different actions depending on this. Beginning would "spark an interest", body would "keep wondering", end would "blow your mind". And perhaps a writer is not always the guru of attention. So at deeper level agent would want to ask a guru, a shaman, a psychologist of how to define a part of his prompt better to do what guru of attention does best – bewilder.

And guru will want some context, like what has been told so far to gauge the current mindset of the audience. And based on that best know what to suggest.

Guru became guru not because his system prompt told him to, but when system is available, he asks himself how to become a better guru. He devoted processing time and iterations to this – something that writer – master of painting a picture with words – has not done. Because he has devoted his processing spare time to learn to paint a better picture with words.

And even if huge models are trained on all data available from humankind it still is not trained on future discoveries and formulas of suffering that lead to them.

Very soon we will stop understanding what the heck the process is doing. Funny thing, so will separate agents. It is important to maintain some form of high level control. Event grid is about that.

SYNC (used in a sentence like "link", e.g. "Synced tightly together", "Sync of a chain", "Weakest sync") is a feature similar to event in JavaScript. WHEN user pressed a button, or when chat message arrived, etc. THEN draw less shadow under the button rectangle, or blink a window.

In a WHENTHEN of agents WHEN we are in a node of EVENT_GRID or WHEN SPARE_TIME -> THEN UPDATE prompt variable with guru123 AS their favorite apprentice.

System of logging of such a thing must be "at least one log per agent" and no timestamped but whenthen id'ed.

Beauty of "whenthen id'ing" of logs is that it is a stacktrace that does not need to be created and stored separately or in forms of horrible stacktrace errors that plague logs.

More then that, it is a testing system in disguise. If you want to debug agent, you have all the surrounding values hard coded for a unit test or even training.

Training agents is not like training NN it is not a huge amount of data needed to reach global minimum of error. It is two small subsets of his output – desired and undesired – that was produced with a given input by agent with this prompt. It is a prompt in itself waiting to happen, "what would be a better prompt for this agent then?"

Learning of model is done. It has reached its loss minima. Now we reap the gain maxima.

The next level language will be such that every declared item or variable will have description field attached.